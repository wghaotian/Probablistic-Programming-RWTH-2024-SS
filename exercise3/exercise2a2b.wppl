// exercise2ab
var metropolisHelper = function(n, f, prop, x_old, samples, times) {
  
  // times: to calculate the times of accept
  if (samples.length === n) {
    console.log(times)
    return samples;
  } 
  else {
    // Generate a proposal sample from the proposal distribution
    var x_new = sample(prop(x_old));

    // Calculate acceptance probability
    var acceptance_prob = Math.min(1, f(x_new) / f(x_old));
    

    // Determine whether to accept the proposal
    if (flip(acceptance_prob)) {
      // Accept the proposal
      return metropolisHelper(n, f, prop, x_new, samples.concat(x_new), times + 1);
    } else {
      // Reject the proposal and keep the old sample
      return metropolisHelper(n, f, prop, x_old, samples.concat(x_old), times);
    }
  }
};

var metropolis = function(n, f, prop) {
  return metropolisHelper(n, f, prop, 0.2, [], 0)
}


var prop = function(mean){
  return Gaussian({mu: mean, sigma: 0.3});
}

var n = 20000; // Number of samples
var f1 = function(x) { 
  var result = 0.5 * Math.exp(-(Math.pow(x-2, 2) / 2)) + 0.5 * Math.exp(-(Math.pow(x+2, 2) / 2));
  return result;
}; 
var f2 = function(x) {
  var result = (x > -3 && x < 3) ? ( -0.1319 * Math.pow(x, 4) + 1.132 * Math.pow(x, 2) + 0.5) : 0
  return result
}
var samples1 = metropolis(n, f1, prop);
var samples2 = metropolis(n, f2, prop);
viz.hist(samples1)
viz.hist(samples2)